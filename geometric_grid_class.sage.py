# This file was *autogenerated* from the file geometric_grid_class.sage
from sage.all_cmdline import *   # import sage library
_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_99999999 = Integer(99999999); _sage_const_5 = Integer(5); _sage_const_0p001 = RealNumber('0.001')# from __future__ import print_function
import sys
sys.setrecursionlimit(_sage_const_99999999 )

# All grids
# n = 2
# m = 2
# k = 7
# grid = [ [ None for j in range(m) ] for i in range(n) ]

# A specific grid
grid = [[_sage_const_1 ,-_sage_const_1 ],[_sage_const_1 ,-_sage_const_1 ]]
n = len(grid)
m = len(grid[_sage_const_0 ])
k = _sage_const_7 

# EPS = 1e-9
# EPS = 1e-9
EPS = _sage_const_0p001  # k*EPS < 1

class Node:
    def __init__(self, id, parent=None):
        self.id = id
        self.left = None
        self.right = None
        self.parent = parent

class BinarySearchTree:

    def __init__(self):
        self.root = None
        self.node = {}

    def attach_right(self, id, node):
        while node.right is not None:
            node = node.right
        node.right = self.node[id] = Node(id, node)

    def attach_left(self, id, node):
        while node.left is not None:
            node = node.left
        node.left = self.node[id] = Node(id, node)

    def insert_before(self, id, right_id):
        assert right_id is None or right_id in self.node
        if right_id is None:
            if self.root is None:
                self.root = self.node[id] = Node(id)
            else:
                self.attach_right(id, self.root)
        else:
            right_node = self.node[right_id]
            if right_node.left is None:
                right_node.left = self.node[id] = Node(id, right_node)
            else:
                self.attach_right(id, right_node.left)

        trav = self.inorder_traversal()
        if right_id is None:
            assert trav[-_sage_const_1 ] == id
        else:
            assert trav.index(id) + _sage_const_1  == trav.index(right_id)

    def insert_after(self, id, left_id):
        assert left_id is None or left_id in self.node
        if left_id is None:
            if self.root is None:
                self.root = self.node[id] = Node(id)
            else:
                self.attach_left(id, self.root)
        else:
            left_node = self.node[left_id]
            if left_node.right is None:
                left_node.right = self.node[id] = Node(id, left_node)
            else:
                self.attach_left(id, left_node.right)

        trav = self.inorder_traversal()
        if left_id is None:
            assert trav[_sage_const_0 ] == id
        else:
            assert trav.index(id) - _sage_const_1  == trav.index(left_id)

    def remove(self, id):
        node = self.node[id]
        del self.node[id]
        assert node.left is None
        assert node.right is None
        if node.parent is None:
            self.root = None
        elif node.parent.left == node:
            node.parent.left = None
        elif node.parent.right == node:
            node.parent.right = None
        else:
            assert False

    def inorder_traversal(self):
        res = []
        def dfs(v):
            if v is None: return
            dfs(v.left)
            res.append(v.id)
            dfs(v.right)
        dfs(self.root)
        return res

def construct_permutation(rows, cols):
    n = len(rows)
    m = len(cols)
    l = sum( len(c) for c in cols )
    idx = [-_sage_const_1 ]*l
    perm = [-_sage_const_1 ]*l
    at = _sage_const_0 
    for i in range(m):
        for j in range(len(cols[i])):
            idx[cols[i][j]] = at
            at += _sage_const_1 

    at = _sage_const_1 
    for i in range(n-_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ):
        for j in range(len(rows[i])-_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ):
            perm[idx[rows[i][j]]] = at
            at += _sage_const_1 

    return tuple(perm)

def is_valid(rows, cols):
    # return True
    p = MixedIntegerLinearProgram()
    n = len(rows)
    m = len(cols)
    l = sum( len(c) for c in cols )

    colorder = []
    for i in range(n):
        for j in range(len(cols[i])):
            colorder.append(cols[i][j])

    rowidx = [-_sage_const_1 ]*l
    colidx = [-_sage_const_1 ]*l
    idx = [-_sage_const_1 ]*l
    at = _sage_const_0 
    for i in range(m):
        for j in range(len(cols[i])):
            idx[cols[i][j]] = at
            at += _sage_const_1 
    for i in range(m):
        for j in range(len(cols[i])):
            colidx[cols[i][j]] = i
    for i in range(n):
        for j in range(len(rows[i])):
            rowidx[rows[i][j]] = i

    var = p.new_variable(real=True,nonnegative=True)
    p.set_objective(var[_sage_const_0 ])

    for i in range(l):
        y = n-rowidx[colorder[i]]-_sage_const_1 
        x = colidx[colorder[i]]
        p.add_constraint(x+EPS <= var[colorder[i]] <= x+_sage_const_1 -EPS)

    for i in range(l-_sage_const_1 ):
        p.add_constraint(var[colorder[i]]+EPS <= var[colorder[i+_sage_const_1 ]])

    order = []
    for i in range(n):
        for j in range(len(rows[i])):
            order.append(rows[i][j])

    for i in range(l-_sage_const_1 ):
        a = order[i]
        b = order[i+_sage_const_1 ]

        aj = n-rowidx[a]-_sage_const_1 
        ai = colidx[a]

        bj = n-rowidx[b]-_sage_const_1 
        bi = colidx[b]

        f = lambda x: (aj - (x - ai) + _sage_const_1 ) if grid[rowidx[a]][colidx[a]] == -_sage_const_1  else (aj + x - ai)
        g = lambda x: (bj - (x - bi) + _sage_const_1 ) if grid[rowidx[b]][colidx[b]] == -_sage_const_1  else (bj + x - bi)

        p.add_constraint(f(var[a]) - EPS >= g(var[b]))

    try:
        p.solve()
        return True
    except:
        return False

rows = [ BinarySearchTree() for i in range(n) ]
cols = [ BinarySearchTree() for i in range(m) ]
res = {}
extra = {}

def bt(k,x,y, id):
    if y == m:
        bt(k, x + _sage_const_1 , _sage_const_0 , id)
        return
    elif x == n:
        # print(grid)
        # for r in range(n):
        #     print('row', r, rows[r].inorder_traversal())
        # for c in range(m):
        #     print('col', c, cols[c].inorder_traversal())
        # gridt = tuple([ tuple(row) for row in grid ])
        # print('xxx')

        roworders = [ row.inorder_traversal() for row in rows ]
        colorders = [ col.inorder_traversal() for col in cols ]
        gridt = tuple([ tuple(row) for row in grid ])
        perm = construct_permutation(roworders, colorders)
        res.setdefault(gridt,set())
        extra.setdefault(gridt,set())
        if is_valid(roworders, colorders):
            res[gridt].add(perm)
        else:
            extra[gridt].add(perm)
        return

    hlines = rows[x].inorder_traversal()
    vlines = cols[y].inorder_traversal()

    horizontal = len(hlines)
    vertical = len(vlines)

    def bt2(k,i,j, id, must):

        if k > _sage_const_0 :
            # put one more here
            # print('another in ', x,y, i,j, hlines, vlines)
            if grid[x][y] == -_sage_const_1 :
                rows[x].insert_before(id, hlines[i] if i < len(hlines) else None)
            else:
                rows[x].insert_after(id, hlines[i-_sage_const_1 ] if _sage_const_0  <= i-_sage_const_1  else None)
            cols[y].insert_before(id, vlines[j] if j < len(vlines) else None)
            bt2(k - _sage_const_1 , i, j, id + _sage_const_1 , False)
            rows[x].remove(id)
            cols[y].remove(id)

        if not must:
            # don't put anything more down
            bt(k, x, y + _sage_const_1 , id)

            # jump somewhere else
            if k > _sage_const_0 :
                di = -grid[x][y]
                dj = _sage_const_1 

                for up in range( i+_sage_const_1  if grid[x][y] == _sage_const_1  else horizontal+_sage_const_1  - i ):
                    for right in range(vertical+_sage_const_1  - j):

                        # don't jump here again...
                        if up == _sage_const_0  and right == _sage_const_0 :
                            continue

                        bt2(k, i + up * di, j + right * dj, id, True)

    lo = -_sage_const_1 
    hi = _sage_const_1 
    if grid[x][y] is not None:
        lo = hi = grid[x][y]

    for t in range(lo,hi+_sage_const_1 ):
        grid[x][y] = t

        if t == _sage_const_1 :
            # increasing at (x,y)
            bt2(k, horizontal, _sage_const_0 , id, False)
        elif t == -_sage_const_1 :
            # decreasing at (x,y)
            bt2(k, _sage_const_0 , _sage_const_0 , id, False)
        else:
            # empty at (x,y)
            bt(k, x, y + _sage_const_1 , id)

    if lo < hi:
        grid[x][y] = None

bt(k, _sage_const_0 , _sage_const_0 , _sage_const_0 )

for gridt in res:
    print('GRID', gridt)
    cnt = {}
    for perm in sorted(res[gridt], key=lambda p: (len(p), p)):
        cnt.setdefault(len(perm), _sage_const_0 )
        cnt[len(perm)] += _sage_const_1 
    for k,v in sorted(cnt.items()):
        print(k,v)
    for perm in sorted(extra[gridt], key=lambda p: (len(p), p)):
        if perm in res[gridt]: continue
        if len(perm) == _sage_const_5 :
            print('Extra', perm)

